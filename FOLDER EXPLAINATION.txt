BACKEND FOLDER EXPLNATION
1. Config
👉 Where you put configuration files (settings, DB connection, environment variables, etc.).
Holds setup logic that rarely changes (e.g., database connection, API keys).
Central place so you don’t repeat configs everywhere.
2. Middleware
👉 Functions that sit between the request and the response.
They run before your request reaches the controller.
Examples:
Parse JSON (express.json())
Enable CORS
Authentication check (isLoggedIn)
Logging requests
3. Routes
👉 Where you define endpoints (URLs) and map them to controllers.
Example: /api/users, /api/bookings, /api/services
Keeps all URL paths organized.
4. Controller
👉 Holds the logic for handling requests and returning responses.
Think: What happens when a route is called? 
Routes send requests → Controllers handle them → Responses go back.
5. Models
👉 Directly handle the database queries.
This is where SQL (or ORM methods) live.
Controllers call models instead of writing SQL directly.


Request → Middleware → Route → Controller → Model → DB → Response
Who talks directly to server.js?
The client (frontend or Postman) → makes an HTTP request
Example:
POST http://localhost:3001/api/users/register


When that request arrives:
1. server.js receives it (through Express).
It has app.use('/api/users', userRoutes) or similar.
So it knows: “Oh, anything that starts with /api/users → forward to the user routes file.”
2. Routes file (e.g. user.routes.js) takes over.
Example: router.post('/register', userController.register);
That says: “If the URL ends with /register and it’s a POST request → run the register controller function.”
3. Controller runs the business logic.
It calls the Model to talk to the Database.
After getting results, it sends a response back.

🔹 Simplified analogy

server.js = Airport → checks what airline (feature/route) you belong to.
Routes = Airline desk → directs you to the right gate (controller).
Controller = Flight crew → handles your journey (business logic).
Model = Control tower → communicates with the database.
Database = The actual city you’re trying to reach (the data).

FRONTEND SIDE
1 pages/ (or app/ in Next.js 13+)
👉 Defines your routes (URLs) automatically in Next.js.
pages/index.js → /
pages/login.js → /login
pages/dashboard.js → /dashboard
In plain React (with React Router), this is equivalent to your route definitions.
So: Frontend Pages = Backend Routes

2. components/
👉 Reusable UI pieces.
Buttons, Forms, Navbar, Sidebar, Cards, etc.
Keeps code DRY (Don’t Repeat Yourself).
Example: <LoginForm />, <Navbar />.
So: Components = building blocks of the UI

5. utils/
👉 Helper functions (format dates, validate forms, constants).  
Example: formatDate(), calculateTotal().

hooks/ (optional)
4👉 Custom React hooks for reusable logic.
Example: useAuth() to check if user is logged in.
Example: useFetch() for making API calls.
So: Hooks = small helper logic pieces you can reuse.

✈️ Analogy (Frontend + Backend Together)

Frontend Pages = Airport check-in (decide which UI to show, e.g., login page or dashboard).
Frontend Components = Boarding passes, security check, gates (UI pieces).
Frontend Services/API = Talk to backend airline desk (send requests).
Backend Controllers/Models = Airline staff + control tower (do the actual work).
Database = Destination city (real data).